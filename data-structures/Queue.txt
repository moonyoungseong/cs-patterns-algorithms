Queue<T> 개념정의: Queue<T>는 FIFO(First-In First-Out) 구조를 따르는 컬렉션(큐)이다.즉 먼저 넣은 항목이 먼저 나간다.기본 연산Enqueue(item) : 항목 추가(뒤에 넣음)T Dequeue() : 맨 앞 항목 꺼내고 제거T Peek() : 맨 앞 항목을 제거하지 않고 조회Count : 현재 큐에 들어있는 항목 수Clear() : 전부 비우기복잡도: 삽입/삭제/조회는 평균적으로 O(1) (상수 시간)언제 쓰나?: 순서대로 처리해야 할 작업들에 적합작업 요청(명령)을 순서대로 처리할 때이벤트/메시지 처리 파이프라인AI 행동 대기열 (먼저 넣은 행동 먼저 수행)적/오브젝트 스폰 대기열네트워크 패킷 처리(순서 보장 필요 시)코루틴으로 순차 처리할 작업 큐2) 유니티에서 Queue를 주로 쓰는 대표적 상황스폰 큐 (Spawn Queue)적들을 한 번에 생성하지 않고 순차적으로 소환할 때. (한 번에 부하 방지)작업 큐 / 태스크 큐게임 내에서 처리해야 할 일(예: 연출, 트랜지션, 서버 응답 처리)을 순서대로 처리AI 행동 큐NPC에게 “순찰 → 조사 → 공격” 같은 행동을 순차적으로 넣고 실행오브젝트 풀링(재사용)에서 대기열비활성화된 오브젝트를 큐에 넣어 필요하면 Dequeue해서 사용유저 입력 매크로 / 명령 큐플레이어가 입력한 커맨드를 저장해 순차 재생(매크로)할 때3) Queue 장단점 요약장점순서 보장(선입선출)삽입/삭제가 빠름(O(1))구현이 간단하고 직관적단점중간 항목에 직접 접근 불가(순회는 가능하지만 인덱스 접근 불가)우선순위 필요하면 PriorityQueue 등 별도 자료구조 필요4) 유니티에서 가장 많이 쓰이는 방식 — 실용 예시 (설명)스폰 큐 + 코루틴 처리 조합이 제일 흔함:웨이브별 적 스폰 정보를 큐에 넣어두고, 코루틴이 Dequeue() 해서 일정 간격으로 생성.장점: 성능 분산, 스폰 타이밍 제어 쉬움.작업 큐(Invoker 패턴과 결합):외부에서 명령 객체(또는 델리게이트)를 Enqueue 하면 메인 루프에서 하나씩 처리.Undo/Redo는 아니지만, 순차적 이벤트 관리에 좋음.